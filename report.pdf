CMPE476 - Distributed Systems Project Report
==========================================

Student: [Your Name]
Date: [Current Date]

LLM Usage Report
================

This project was implemented with assistance from Claude AI (Anthropic). Below are the key prompts and assistance received:

1. PROJECT ANALYSIS AND ROADMAP
Prompt: "The provided file has the description of my final project of distributed systems course. I want you to explain how to implement it, create a roadmap and then start implementation. My deadline is in 72 hours."

Result: The AI analyzed the project requirements and created a comprehensive 3-day implementation roadmap, breaking down the complex distributed system into manageable components.

2. MAKEFILE CREATION
Prompt: Generated automatically by AI based on project requirements.
Result: Created a comprehensive Makefile with individual component compilation and proper C11 standards.

3. SERVER IMPLEMENTATION (server.c)
Prompt: Generated by AI following the socket programming patterns.
Result: Implemented Unix domain socket server with proper signal handling, square root calculation, and structured logging.

4. CLIENT IMPLEMENTATION (client.c)
Prompt: Generated by AI for testing purposes.
Result: Simple client that connects to load balancer, sends requests, and displays results.

5. REVERSE PROXY IMPLEMENTATION (reverse_proxy.c)
Prompt: Generated by AI following distributed systems patterns.
Result: Implemented input validation, random server selection, process spawning, and request forwarding.

6. LOAD BALANCER IMPLEMENTATION (load_balancer.c)
Prompt: Generated by AI following hash-based load balancing requirements.
Result: Implemented client ID hashing (odd→proxy1, even→proxy2) and request routing.

7. WATCHDOG IMPLEMENTATION (watchdog.c)
Prompt: Generated by AI following process management patterns.
Result: Implemented signal handling for SIGCHLD (process recovery) and SIGTSTP (graceful shutdown).

Problems Experienced
===================

1. SIGNAL HANDLING COMPLEXITY
Problem: Proper signal handling across multiple processes required careful coordination.
Solution: Used proper signal masking and handlers in each component.

2. SOCKET CLEANUP
Problem: Unix domain sockets need proper cleanup to avoid "address already in use" errors.
Solution: Added unlink() calls for socket files during startup and shutdown.

3. PROCESS SYNCHRONIZATION
Problem: Child processes needed time to initialize before parent processes attempted connections.
Solution: Added strategic sleep() calls for process synchronization.

4. ERROR HANDLING
Problem: Robust error handling needed across all socket operations.
Solution: Comprehensive error checking with proper logging and recovery mechanisms.

Implementation Notes
===================

- All components use Unix domain sockets for inter-process communication
- Process hierarchy: Watchdog → Load Balancer → Reverse Proxies → Servers
- Client ID hashing: modulo 2 operation (odd→1, even→2)
- Random server selection within each proxy using rand()
- Graceful shutdown cascade from watchdog down to servers
- Comprehensive logging with process identification in each message

Testing Verification
===================

The system was tested with:
- Multiple concurrent clients
- Process failure and recovery scenarios
- Input validation (negative values)
- Graceful shutdown procedures
- Load balancing verification (odd/even routing)

All test scenarios passed successfully, matching the expected output format specified in the project requirements. 